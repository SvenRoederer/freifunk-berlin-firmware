From: adminuser <adminuser@cvt.bln.roederer.dhs.org>
Date: Wed, 2 Dec 2020 01:17:20 +0100
Subject: Merge "use 4K erase only where need" (PR https://github.com/openwrt/openwrt/pull/3271)

diff --git a/package/utils/mtd-utils/Makefile b/package/utils/mtd-utils/Makefile
index 6e5e72783f55d426da896eeb9e398aaff7c11045..dbde0339c575494512c4342925b2dcf8663117c5 100644
--- a/package/utils/mtd-utils/Makefile
+++ b/package/utils/mtd-utils/Makefile
@@ -54,6 +54,15 @@ define Package/nand-utils/description
   Utilities for NAND devices.
 endef
 
+define Package/mtd-utils-debug
+ $(call Package/mtd-utils/Default)
+  TITLE:=Utilities for mtd flash erase/read/write/test debug
+endef
+
+define Package/mtd-utils-debug/description
+  Utilities for MTD device debug.
+endef
+
 MAKE_FLAGS += LDLIBS+="$(LIBGCC_S)"
 
 CONFIGURE_ARGS += \
@@ -80,5 +89,12 @@ define Package/nand-utils/install
 	$(PKG_INSTALL_DIR)/usr/sbin/{flash_erase,nanddump,nandwrite,nandtest,mtdinfo} $(1)/usr/sbin/
 endef
 
+define Package/mtd-utils-debug/install
+	$(INSTALL_DIR) $(1)/usr/sbin
+	$(INSTALL_BIN) \
+	$(PKG_INSTALL_DIR)/usr/sbin/mtd_debug $(1)/usr/sbin/
+endef
+
 $(eval $(call BuildPackage,ubi-utils))
 $(eval $(call BuildPackage,nand-utils))
+$(eval $(call BuildPackage,mtd-utils-debug))
diff --git a/target/linux/generic/pending-5.4/411-mtd-partial_eraseblock_write.patch b/target/linux/generic/pending-5.4/411-mtd-partial_eraseblock_write.patch
deleted file mode 100644
index c48a144d3de66437b8c6f0f03bfd9d7bf98a5666..0000000000000000000000000000000000000000
--- a/target/linux/generic/pending-5.4/411-mtd-partial_eraseblock_write.patch
+++ /dev/null
@@ -1,130 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Subject: mtd: implement write support for partitions covering only a part of an eraseblock (buffer data that would otherwise be erased)
-
-lede-commit: 87a8e8ac1067f58ba831c4aae443f3655c31cd80
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- drivers/mtd/mtdpart.c   | 90 ++++++++++++++++++++++++++++++++++++++++++++-----
- include/linux/mtd/mtd.h |  4 +++
- 2 files changed, 85 insertions(+), 9 deletions(-)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -22,6 +22,8 @@
- #include "mtdcore.h"
- #include "mtdsplit/mtdsplit.h"
- 
-+#define MTD_ERASE_PARTIAL	0x8000 /* partition only covers parts of an erase block */
-+
- /* Our partition linked list */
- static LIST_HEAD(mtd_partitions);
- static DEFINE_MUTEX(mtd_partitions_mutex);
-@@ -206,11 +208,77 @@ static int part_erase(struct mtd_info *m
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
- 	int ret;
-+	size_t wrlen = 0;
-+	u8 *erase_buf = NULL;
-+	u32 erase_buf_ofs = 0;
-+	bool partial_start = false;
-+
-+	if (mtd->flags & MTD_ERASE_PARTIAL) {
-+		size_t readlen = 0;
-+		u64 mtd_ofs;
-+
-+		erase_buf = kmalloc(part->parent->erasesize, GFP_ATOMIC);
-+		if (!erase_buf)
-+			return -ENOMEM;
-+
-+		mtd_ofs = part->offset + instr->addr;
-+		erase_buf_ofs = do_div(mtd_ofs, part->parent->erasesize);
-+
-+		if (erase_buf_ofs > 0) {
-+			instr->addr -= erase_buf_ofs;
-+			ret = mtd_read(part->parent,
-+				instr->addr + part->offset,
-+				part->parent->erasesize,
-+				&readlen, erase_buf);
-+
-+			instr->len += erase_buf_ofs;
-+			partial_start = true;
-+		} else {
-+			mtd_ofs = part->offset + part->mtd.size;
-+			erase_buf_ofs = part->parent->erasesize -
-+				do_div(mtd_ofs, part->parent->erasesize);
-+
-+			if (erase_buf_ofs > 0) {
-+				instr->len += erase_buf_ofs;
-+				ret = mtd_read(part->parent,
-+					part->offset + instr->addr +
-+					instr->len - part->parent->erasesize,
-+					part->parent->erasesize, &readlen,
-+					erase_buf);
-+			} else {
-+				ret = 0;
-+			}
-+		}
-+		if (ret < 0) {
-+			kfree(erase_buf);
-+			return ret;
-+		}
-+
-+	}
- 
- 	instr->addr += part->offset;
- 	ret = part->parent->_erase(part->parent, instr);
- 	if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
- 		instr->fail_addr -= part->offset;
-+
-+	if (mtd->flags & MTD_ERASE_PARTIAL) {
-+		if (partial_start) {
-+			part->parent->_write(part->parent,
-+				instr->addr, erase_buf_ofs,
-+				&wrlen, erase_buf);
-+			instr->addr += erase_buf_ofs;
-+		} else {
-+			instr->len -= erase_buf_ofs;
-+			part->parent->_write(part->parent,
-+				instr->addr + instr->len,
-+				erase_buf_ofs, &wrlen,
-+				erase_buf +
-+				part->parent->erasesize -
-+				erase_buf_ofs);
-+		}
-+		kfree(erase_buf);
-+	}
-+
- 	instr->addr -= part->offset;
- 
- 	return ret;
-@@ -525,19 +593,22 @@ static struct mtd_part *allocate_partiti
- 	remainder = do_div(tmp, wr_alignment);
- 	if ((slave->mtd.flags & MTD_WRITEABLE) && remainder) {
- 		/* Doesn't start on a boundary of major erase size */
--		/* FIXME: Let it be writable if it is on a boundary of
--		 * _minor_ erase size though */
--		slave->mtd.flags &= ~MTD_WRITEABLE;
--		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase/write block boundary -- force read-only\n",
--			part->name);
-+		slave->mtd.flags |= MTD_ERASE_PARTIAL;
-+		if (((u32)slave->mtd.size) > parent->erasesize)
-+			slave->mtd.flags &= ~MTD_WRITEABLE;
-+		else
-+			slave->mtd.erasesize = slave->mtd.size;
- 	}
- 
- 	tmp = part_absolute_offset(parent) + slave->offset + slave->mtd.size;
- 	remainder = do_div(tmp, wr_alignment);
- 	if ((slave->mtd.flags & MTD_WRITEABLE) && remainder) {
--		slave->mtd.flags &= ~MTD_WRITEABLE;
--		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase/write block -- force read-only\n",
--			part->name);
-+		slave->mtd.flags |= MTD_ERASE_PARTIAL;
-+
-+		if ((u32)slave->mtd.size > parent->erasesize)
-+			slave->mtd.flags &= ~MTD_WRITEABLE;
-+		else
-+			slave->mtd.erasesize = slave->mtd.size;
- 	}
- 
- 	mtd_set_ooblayout(&slave->mtd, &part_ooblayout_ops);
diff --git a/target/linux/generic/pending-5.4/412-mtd-partial_eraseblock_unlock.patch b/target/linux/generic/pending-5.4/412-mtd-partial_eraseblock_unlock.patch
deleted file mode 100644
index b23bc1b20161aa283348a0dba9042447fc0f02df..0000000000000000000000000000000000000000
--- a/target/linux/generic/pending-5.4/412-mtd-partial_eraseblock_unlock.patch
+++ /dev/null
@@ -1,40 +0,0 @@
-From: Tim Harvey <tharvey@gateworks.com>
-Subject: mtd: allow partial block unlock
-
-This allows sysupgrade for devices such as the Gateworks Avila/Cambria
-product families based on the ixp4xx using the redboot bootloader with
-combined FIS directory and RedBoot config partitions on larger FLASH
-devices with larger eraseblocks.
-
-This second iteration of this patch addresses previous issues:
-- whitespace breakage fixed
-- unlock in all scenarios
-- simplification and fix logic bug
-
-[john@phrozen.org: this should be moved to the ixp4xx folder]
-
-Signed-off-by: Tim Harvey <tharvey@gateworks.com>
----
- drivers/mtd/mtdpart.c | 11 ++++++++++-
- 1 file changed, 10 insertions(+), 1 deletion(-)
-
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -293,7 +293,16 @@ static int part_lock(struct mtd_info *mt
- static int part_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
- {
- 	struct mtd_part *part = mtd_to_part(mtd);
--	return part->parent->_unlock(part->parent, ofs + part->offset, len);
-+
-+	ofs += part->offset;
-+
-+	if (mtd->flags & MTD_ERASE_PARTIAL) {
-+		/* round up len to next erasesize and round down offset to prev block */
-+		len = (mtd_div_by_eb(len, part->parent) + 1) * part->parent->erasesize;
-+		ofs &= ~(part->parent->erasesize - 1);
-+	}
-+
-+	return part->parent->_unlock(part->parent, ofs, len);
- }
- 
- static int part_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)
diff --git a/target/linux/generic/pending-5.4/470-mtd-spi-nor-support-limiting-4K-sectors-support-base.patch b/target/linux/generic/pending-5.4/470-mtd-spi-nor-support-limiting-4K-sectors-support-base.patch
deleted file mode 100644
index 7773a8ec05a3dee22ec582e9bc158c15fa955c76..0000000000000000000000000000000000000000
--- a/target/linux/generic/pending-5.4/470-mtd-spi-nor-support-limiting-4K-sectors-support-base.patch
+++ /dev/null
@@ -1,79 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 4 Nov 2017 07:40:23 +0100
-Subject: [PATCH] mtd: spi-nor: support limiting 4K sectors support based on
- flash size
-
-Some devices need 4K sectors to be able to deal with small flash chips.
-For instance, w25x05 is 64 KiB in size, and without 4K sectors, the
-entire chip is just one erase block.
-On bigger flash chip sizes, using 4K sectors can significantly slow down
-many operations, including using a writable filesystem. There are several
-platforms where it makes sense to use a single kernel on both kinds of
-devices.
-
-To support this properly, allow configuring an upper flash chip size
-limit for 4K sectors support.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/mtd/spi-nor/Kconfig
-+++ b/drivers/mtd/spi-nor/Kconfig
-@@ -34,6 +34,17 @@ config SPI_ASPEED_SMC
- 	  and support for the SPI flash memory controller (SPI) for
- 	  the host firmware. The implementation only supports SPI NOR.
- 
-+config MTD_SPI_NOR_USE_4K_SECTORS_LIMIT
-+	int "Maximum flash chip size to use 4K sectors on (in KiB)"
-+	depends on MTD_SPI_NOR_USE_4K_SECTORS
-+	default "4096"
-+	help
-+	  There are many flash chips that support 4K sectors, but are so large
-+	  that using them significantly slows down writing large amounts of
-+	  data or using a writable filesystem.
-+	  Any flash chip larger than the size specified in this option will
-+	  not use 4K sectors.
-+
- config SPI_CADENCE_QUADSPI
- 	tristate "Cadence Quad SPI controller"
- 	depends on OF && (ARM || ARM64 || COMPILE_TEST)
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -4463,6 +4463,7 @@ static void spi_nor_info_init_params(str
- 	struct spi_nor_erase_map *map = &params->erase_map;
- 	const struct flash_info *info = nor->info;
- 	struct device_node *np = spi_nor_get_flash_node(nor);
-+	struct mtd_info *mtd = &nor->mtd;
- 	u8 i, erase_mask;
- 
- 	/* Initialize legacy flash parameters and settings. */
-@@ -4526,6 +4527,21 @@ static void spi_nor_info_init_params(str
- 	 */
- 	erase_mask = 0;
- 	i = 0;
-+#ifdef CONFIG_MTD_SPI_NOR_USE_4K_SECTORS
-+	if ((info->flags & SECT_4K_PMC) && (mtd->size <=
-+		   CONFIG_MTD_SPI_NOR_USE_4K_SECTORS_LIMIT * 1024)) {
-+		erase_mask |= BIT(i);
-+		spi_nor_set_erase_type(&map->erase_type[i], 4096u,
-+				       SPINOR_OP_BE_4K_PMC);
-+		i++;
-+	} else if ((info->flags & SECT_4K) && (mtd->size <=
-+	    CONFIG_MTD_SPI_NOR_USE_4K_SECTORS_LIMIT * 1024)) {
-+		erase_mask |= BIT(i);
-+		spi_nor_set_erase_type(&map->erase_type[i], 4096u,
-+				       SPINOR_OP_BE_4K);
-+		i++;
-+	}
-+#else
- 	if (info->flags & SECT_4K_PMC) {
- 		erase_mask |= BIT(i);
- 		spi_nor_set_erase_type(&map->erase_type[i], 4096u,
-@@ -4537,6 +4553,7 @@ static void spi_nor_info_init_params(str
- 				       SPINOR_OP_BE_4K);
- 		i++;
- 	}
-+#endif
- 	erase_mask |= BIT(i);
- 	spi_nor_set_erase_type(&map->erase_type[i], info->sector_size,
- 			       SPINOR_OP_SE);
diff --git a/target/linux/generic/pending-5.4/499-0-mtd-spi-nor-allow-variable-erase.patch b/target/linux/generic/pending-5.4/499-0-mtd-spi-nor-allow-variable-erase.patch
new file mode 100644
index 0000000000000000000000000000000000000000..464cd8f58655bd8a5bff0da6bd5972a3a8ab33f4
--- /dev/null
+++ b/target/linux/generic/pending-5.4/499-0-mtd-spi-nor-allow-variable-erase.patch
@@ -0,0 +1,151 @@
+--- a/drivers/mtd/mtdpart.c
++++ b/drivers/mtd/mtdpart.c
+@@ -331,8 +331,9 @@ static struct mtd_part *allocate_partiti
+ {
+ 	int wr_alignment = (parent->flags & MTD_NO_ERASE) ? parent->writesize :
+ 							    parent->erasesize;
++	int wr_alignment_minor = parent->erasesize_minor;
+ 	struct mtd_part *slave;
+-	u32 remainder;
++	u32 remainder, remainder_minor;
+ 	char *name;
+ 	u64 tmp;
+ 
+@@ -433,6 +434,9 @@ static struct mtd_part *allocate_partiti
+ 	if (parent->_put_device)
+ 		slave->mtd._put_device = part_put_device;
+ 
++	if (parent->erasesize_minor)
++		slave->mtd.erasesize_minor = parent->erasesize_minor;
++
+ 	slave->mtd._erase = part_erase;
+ 	slave->parent = parent;
+ 	slave->offset = part->offset;
+@@ -523,21 +527,41 @@ static struct mtd_part *allocate_partiti
+ 
+ 	tmp = part_absolute_offset(parent) + slave->offset;
+ 	remainder = do_div(tmp, wr_alignment);
+-	if ((slave->mtd.flags & MTD_WRITEABLE) && remainder) {
+-		/* Doesn't start on a boundary of major erase size */
+-		/* FIXME: Let it be writable if it is on a boundary of
+-		 * _minor_ erase size though */
+-		slave->mtd.flags &= ~MTD_WRITEABLE;
+-		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase/write block boundary -- force read-only\n",
+-			part->name);
++	if (remainder && wr_alignment_minor) {
++		tmp = part_absolute_offset(parent) + slave->offset;
++		remainder_minor = do_div(tmp, wr_alignment_minor);
++	}
++	if (slave->mtd.flags & MTD_WRITEABLE){
++		if (!remainder){
++			/* Does start on a boundary of major erase size */
++		} else if (wr_alignment_minor && !remainder_minor){
++			/* Does start on a boundary of minor erase size */
++			slave->mtd.erasesize = parent->erasesize_minor;
++		} else {
++			slave->mtd.flags &= ~MTD_WRITEABLE;
++			printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase/write block boundary -- force read-only\n",
++				part->name);
++		}
+ 	}
+ 
+ 	tmp = part_absolute_offset(parent) + slave->offset + slave->mtd.size;
+ 	remainder = do_div(tmp, wr_alignment);
+-	if ((slave->mtd.flags & MTD_WRITEABLE) && remainder) {
+-		slave->mtd.flags &= ~MTD_WRITEABLE;
+-		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase/write block -- force read-only\n",
+-			part->name);
++	if (remainder && wr_alignment_minor) {
++		tmp = part_absolute_offset(parent) +
++		      slave->offset + slave->mtd.size;
++		remainder_minor = do_div(tmp, wr_alignment_minor);
++	}
++	if (slave->mtd.flags & MTD_WRITEABLE){
++		if (!remainder){
++			/* Does end on a boundary of major erase size */
++		} else if (wr_alignment_minor && !remainder_minor){
++			/* Does end on a boundary of minor erase size */
++			slave->mtd.erasesize = parent->erasesize_minor;
++		} else {
++			slave->mtd.flags &= ~MTD_WRITEABLE;
++			printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase/write block -- force read-only\n",
++				part->name);
++		}
+ 	}
+ 
+ 	mtd_set_ooblayout(&slave->mtd, &part_ooblayout_ops);
+--- a/drivers/mtd/spi-nor/Kconfig
++++ b/drivers/mtd/spi-nor/Kconfig
+@@ -24,6 +24,14 @@ config MTD_SPI_NOR_USE_4K_SECTORS
+ 	  Please note that some tools/drivers/filesystems may not work with
+ 	  4096 B erase size (e.g. UBIFS requires 15 KiB as a minimum).
+ 
++config MTD_SPI_NOR_USE_VARIABLE_ERASE
++	bool "Disable uniform_erase"
++	default n
++	help
++	  Return false with spi_nor_has_uniform_erase,
++	  so that the multiple eraseregions code path is used.
++	  This allows an erase to use 4K erase where supported and needed.
++
+ config SPI_ASPEED_SMC
+ 	tristate "Aspeed flash controllers in SPI mode"
+ 	depends on ARCH_ASPEED || COMPILE_TEST
+--- a/drivers/mtd/spi-nor/spi-nor.c
++++ b/drivers/mtd/spi-nor/spi-nor.c
+@@ -4346,6 +4346,7 @@ static int spi_nor_select_erase(struct s
+ {
+ 	struct spi_nor_erase_map *map = &nor->params.erase_map;
+ 	const struct spi_nor_erase_type *erase = NULL;
++	const struct spi_nor_erase_type *erase_minor = NULL;
+ 	struct mtd_info *mtd = &nor->mtd;
+ 	u32 wanted_size = nor->info->sector_size;
+ 	int i;
+@@ -4378,15 +4379,20 @@ static int spi_nor_select_erase(struct s
+ 	 */
+ 	for (i = SNOR_ERASE_TYPE_MAX - 1; i >= 0; i--) {
+ 		if (map->erase_type[i].size) {
+-			erase = &map->erase_type[i];
+-			break;
++			if (!erase)
++				erase = &map->erase_type[i];
++			erase_minor = &map->erase_type[i];
+ 		}
+ 	}
+ 
+ 	if (!erase)
+ 		return -EINVAL;
+ 
++	if (!erase_minor)
++		erase_minor = erase;
++
+ 	mtd->erasesize = erase->size;
++	mtd->erasesize_minor = erase_minor->size;
+ 	return 0;
+ }
+ 
+--- a/include/linux/mtd/mtd.h
++++ b/include/linux/mtd/mtd.h
+@@ -205,6 +205,8 @@ struct mtd_info {
+ 	 * information below if they desire
+ 	 */
+ 	uint32_t erasesize;
++	/* "Minor" erase size supported by the whole device */
++	uint32_t erasesize_minor;
+ 	/* Minimal writable flash unit size. In case of NOR flash it is 1 (even
+ 	 * though individual bits can be cleared), in case of NAND flash it is
+ 	 * one NAND page (or half, or one-fourths of it), in case of ECC-ed NOR
+--- a/include/linux/mtd/spi-nor.h
++++ b/include/linux/mtd/spi-nor.h
+@@ -631,7 +631,11 @@ spi_nor_region_mark_overlay(struct spi_n
+ 
+ static bool __maybe_unused spi_nor_has_uniform_erase(const struct spi_nor *nor)
+ {
++#ifdef CONFIG_MTD_SPI_NOR_USE_VARIABLE_ERASE
++	return false;
++#else
+ 	return !!nor->params.erase_map.uniform_erase_type;
++#endif
+ }
+ 
+ static inline void spi_nor_set_flash_node(struct spi_nor *nor,
